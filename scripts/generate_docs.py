#!/usr/bin/env python3
"""Generate documentation from validation reports and fix reports."""

from __future__ import annotations

import argparse
import json
import sys
from datetime import UTC, datetime
from pathlib import Path

from rich.console import Console

console = Console()

FRONTMATTER = """---
title: Validation Report
description: F5 XC API spec validation and fix report
---
"""


def load_json_report(report_path: Path, report_type: str = "report") -> dict | None:
    """Load a JSON report file."""
    if not report_path.exists():
        console.print(f"[yellow]{report_type.capitalize()} not found: {report_path}[/yellow]")
        return None

    try:
        with open(report_path) as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        console.print(f"[red]Failed to parse {report_type}: {e}[/red]")
        return None


def generate_fixes_page(
    validation_report: dict | None,
    fix_report: dict | None,
    output_path: Path,
) -> None:
    """Generate the main documentation page showing fixes applied."""
    lines = [
        FRONTMATTER.strip(),
        "",
        "# F5 XC API Spec Fixes Applied",
        "",
        "Validated and reconciled F5 Distributed Cloud OpenAPI specifications.",
        "",
        "This project validates F5 XC OpenAPI specifications against the live API, "
        "identifies discrepancies, and automatically applies fixes to produce corrected spec files.",
        "",
    ]

    # Add generation timestamp
    now = datetime.now(UTC).strftime("%Y-%m-%d %H:%M UTC")
    lines.extend(
        [
            f"*Last updated: {now}*",
            "",
        ]
    )

    # If we have a fix report, show the summary
    if fix_report:
        summary = fix_report.get("summary", {})
        fixes = fix_report.get("fixes", [])
        failures = fix_report.get("failures", [])

        lines.extend(
            [
                "## Summary",
                "",
                "| Metric | Count |",
                "|--------|-------|",
                f"| Specs Processed | {summary.get('total_specs_processed', 0)} |",
                f"| Discrepancies Found | {summary.get('total_discrepancies_found', 0)} |",
                f"| **Fixes Applied** | **{summary.get('total_fixes_applied', 0)}** |",
                f"| Fixes Failed | {summary.get('total_fixes_failed', 0)} |",
                "",
            ]
        )

        if fixes:
            lines.extend(_generate_fixes_section(fixes))

        if failures:
            lines.extend(_generate_failures_section(failures))

    elif validation_report:
        # Fall back to showing discrepancies from validation report
        lines.extend(_generate_discrepancies_section(validation_report))
    else:
        lines.extend(
            [
                ":::note[No Reports Found]",
                "No validation or fix reports were found. Run the validation pipeline to generate reports.",
                ":::",
                "",
            ]
        )

    # Add legend
    lines.extend(_generate_legend())

    # Footer
    lines.extend(
        [
            "---",
            "",
            "*This page is auto-generated by the [validation pipeline](https://github.com/robinmordasiewicz/f5xc-api-fixed/actions).*",
        ]
    )

    _write_file(output_path, lines)


def _generate_fixes_section(fixes: list[dict]) -> list[str]:
    """Generate the fixes applied section."""
    lines = [
        "## Fixes Applied",
        "",
    ]

    # Group fixes by file
    fixes_by_file: dict[str, list[dict]] = {}
    for fix in fixes:
        filename = fix.get("spec_file", "unknown")
        if filename not in fixes_by_file:
            fixes_by_file[filename] = []
        fixes_by_file[filename].append(fix)

    for filename, file_fixes in sorted(fixes_by_file.items()):
        lines.extend(
            [
                f"### {filename}",
                "",
                "| Property | Constraint | Strategy | Before | After | Evidence |",
                "|----------|------------|----------|--------|-------|----------|",
            ]
        )

        for fix in file_fixes:
            prop = fix.get("property_path", "-")
            constraint = fix.get("constraint_type", "-")
            strategy = _get_strategy_badge(fix.get("fix_strategy", "-"))
            old_val = _format_value(fix.get("original_value"))
            new_val = _format_value(fix.get("new_value"))

            # Extract evidence summary
            evidence = fix.get("test_evidence", {})
            http_status = evidence.get("http_status")
            evidence_str = f"HTTP {http_status}" if http_status else "-"

            lines.append(
                f"| `{prop}` | `{constraint}` | {strategy} | {old_val} | {new_val} | {evidence_str} |"
            )

        # Add collapsible details
        lines.extend(
            [
                "",
                "<details>",
                "<summary>Fix Details</summary>",
                "",
            ]
        )

        for i, fix in enumerate(file_fixes, 1):
            prop = fix.get("property_path", "unknown")
            reason = fix.get("reason", "No reason provided")
            lines.extend(
                [
                    f"**{i}. {prop}**",
                    f"{reason}",
                    "",
                ]
            )

        lines.extend(
            [
                "</details>",
                "",
            ]
        )

    return lines


def _generate_failures_section(failures: list[dict]) -> list[str]:
    """Generate the failed fixes section."""
    lines = [
        "## Failed Fixes",
        "",
        "The following discrepancies could not be automatically fixed:",
        "",
    ]

    # Group failures by file
    failures_by_file: dict[str, list[dict]] = {}
    for failure in failures:
        filename = failure.get("spec_file", "unknown")
        if filename not in failures_by_file:
            failures_by_file[filename] = []
        failures_by_file[filename].append(failure)

    for filename, file_failures in sorted(failures_by_file.items()):
        lines.extend(
            [
                f"### {filename}",
                "",
                "| Property | Constraint | Error |",
                "|----------|------------|-------|",
            ]
        )

        for failure in file_failures:
            prop = failure.get("property_path", "-")
            constraint = failure.get("constraint_type", "-")
            error = _format_value(failure.get("error", "-"))
            lines.append(f"| `{prop}` | `{constraint}` | {error} |")

        lines.append("")

    return lines


def _generate_discrepancies_section(report: dict) -> list[str]:
    """Generate discrepancies section from validation report (legacy format)."""
    discrepancies = report.get("discrepancies", [])
    modified_files = report.get("modified_files", [])
    unmodified_files = report.get("unmodified_files", [])

    lines = [
        "## Summary",
        "",
        f"- **Modified Files**: {len(modified_files)}",
        f"- **Unmodified Files**: {len(unmodified_files)}",
        f"- **Total Discrepancies**: {len(discrepancies)}",
        "",
    ]

    if not discrepancies:
        lines.extend(
            [
                ":::tip[No Modifications Required]",
                "All specs match live API behavior. No modifications were applied.",
                ":::",
                "",
            ]
        )
        return lines

    # Group discrepancies by file
    by_file: dict[str, list] = {}
    for d in discrepancies:
        path = d.get("path", "unknown")
        filename = path.split(":")[0] if ":" in path else path
        if filename not in by_file:
            by_file[filename] = []
        by_file[filename].append(d)

    lines.extend(
        [
            "## Modifications by File",
            "",
        ]
    )

    for filename, file_discrepancies in sorted(by_file.items()):
        lines.extend(
            [
                f"### {filename}",
                "",
                "| Property | Constraint | Type | Spec Value | API Behavior |",
                "|----------|------------|------|------------|--------------|",
            ]
        )

        for d in file_discrepancies:
            prop = d.get("property_name", "-")
            constraint = d.get("constraint_type", "-")
            dtype = d.get("discrepancy_type", "-")
            spec_val = d.get("spec_value", "-")
            api_val = d.get("api_behavior", "-")

            spec_str = _format_value(spec_val)
            api_str = _format_value(api_val)
            dtype_badge = _get_type_badge(dtype)

            lines.append(f"| `{prop}` | `{constraint}` | {dtype_badge} | {spec_str} | {api_str} |")

        lines.append("")

    return lines


def _generate_legend() -> list[str]:
    """Generate the legend section."""
    return [
        "## Fix Strategies",
        "",
        "| Strategy | Description |",
        "|----------|-------------|",
        "| **Relaxed** | Constraint was too strict - API accepts values the spec rejected |",
        "| **Tightened** | Constraint was too loose - API rejects values the spec accepted |",
        "| **Added** | Missing constraint discovered through API testing |",
        "| **Removed** | Extra constraint that API ignores |",
        "| **Updated** | Schema updated to match API response structure |",
        "",
    ]


def _format_value(value) -> str:
    """Format a value for display in markdown table."""
    if value is None:
        return "-"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, (list, dict)):
        json_str = json.dumps(value)
        if len(json_str) > 50:
            return f"`{json_str[:47]}...`"
        return f"`{json_str}`"
    # Replace newlines with HTML line breaks for markdown tables
    str_value = str(value).replace("\n", "<br>")
    # Don't wrap in backticks if it contains HTML
    if "<br>" in str_value:
        return str_value
    return f"`{str_value}`"


def _get_strategy_badge(strategy: str) -> str:
    """Get a badge for the fix strategy."""
    badges = {
        "relax": "**Relaxed**",
        "tighten": "**Tightened**",
        "add": "**Added**",
        "remove": "**Removed**",
        "add_status_code": "**Added Status**",
        "update_schema": "**Updated**",
    }
    return badges.get(strategy.lower(), strategy)


def _get_type_badge(dtype: str) -> str:
    """Get a badge for the discrepancy type."""
    badges = {
        "spec_stricter": "**Relaxed**",
        "spec_looser": "**Tightened**",
        "missing_constraint": "**Added**",
        "extra_constraint": "**Removed**",
        "constraint_mismatch": "**Mismatch**",
        "type_mismatch": "**Type**",
    }
    return badges.get(dtype, dtype)


def _write_file(path: Path, lines: list[str]) -> None:
    """Write lines to file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        f.write("\n".join(lines))
    console.print(f"[green]Generated: {path}[/green]")


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Generate documentation from validation and fix reports"
    )
    parser.add_argument(
        "--validation-report",
        "--report",
        type=Path,
        default=Path("reports/validation_report.json"),
        help="Path to validation report JSON",
    )
    parser.add_argument(
        "--fix-report",
        type=Path,
        default=Path("reports/fixes_applied.json"),
        help="Path to fix report JSON",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("docs/01-validation-report.mdx"),
        help="Output path for documentation page",
    )

    args = parser.parse_args()

    console.print("[bold blue]Generating Documentation[/bold blue]")

    # Load reports
    validation_report = load_json_report(args.validation_report, "validation report")
    fix_report = load_json_report(args.fix_report, "fix report")

    # Generate documentation
    generate_fixes_page(validation_report, fix_report, args.output)

    console.print("[green]Documentation generation complete[/green]")
    return 0


if __name__ == "__main__":
    sys.exit(main())
