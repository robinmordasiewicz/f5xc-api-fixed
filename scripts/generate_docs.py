#!/usr/bin/env python3
"""Generate documentation from validation reports."""

from __future__ import annotations

import json
import sys
from datetime import UTC, datetime
from pathlib import Path

from rich.console import Console

console = Console()


def load_validation_report(report_path: Path) -> dict | None:
    """Load validation report JSON file."""
    if not report_path.exists():
        console.print(f"[yellow]Report not found: {report_path}[/yellow]")
        return None

    try:
        with open(report_path) as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        console.print(f"[red]Failed to parse report: {e}[/red]")
        return None


def generate_modifications_page(report: dict | None, output_path: Path) -> None:
    """Generate the modifications/index.md page from validation report."""
    lines = [
        "# F5 XC API Fixed Specs",
        "",
        "Validated and reconciled F5 Distributed Cloud OpenAPI specifications.",
        "",
        "This project validates F5 XC OpenAPI specifications against the live API, identifies discrepancies, and produces corrected spec files.",
        "",
    ]

    # Add generation timestamp
    now = datetime.now(UTC).strftime("%Y-%m-%d %H:%M UTC")
    lines.extend(
        [
            f"*Last updated: {now}*",
            "",
        ]
    )

    if not report:
        lines.extend(
            [
                '!!! note "No Validation Report"',
                "    No validation report was found. Run the validation pipeline to generate reports.",
                "",
            ]
        )
        _write_file(output_path, lines)
        return

    # Extract discrepancies
    discrepancies = report.get("discrepancies", [])
    modified_files = report.get("modified_files", [])
    unmodified_files = report.get("unmodified_files", [])

    # Summary section
    lines.extend(
        [
            "## Summary",
            "",
            f"- **Modified Files**: {len(modified_files)}",
            f"- **Unmodified Files**: {len(unmodified_files)}",
            f"- **Total Discrepancies**: {len(discrepancies)}",
            "",
        ]
    )

    if not discrepancies:
        lines.extend(
            [
                '!!! success "No Modifications Required"',
                "    All specs match live API behavior. No modifications were applied.",
                "",
            ]
        )
        _write_file(output_path, lines)
        return

    # Group discrepancies by file
    by_file: dict[str, list] = {}
    for d in discrepancies:
        path = d.get("path", "unknown")
        # Extract filename from path
        filename = path.split(":")[0] if ":" in path else path
        if filename not in by_file:
            by_file[filename] = []
        by_file[filename].append(d)

    # Modifications by file
    lines.extend(
        [
            "## Modifications by File",
            "",
        ]
    )

    for filename, file_discrepancies in sorted(by_file.items()):
        lines.extend(
            [
                f"### {filename}",
                "",
                "| Property | Constraint | Type | Spec Value | API Behavior |",
                "|----------|------------|------|------------|--------------|",
            ]
        )

        for d in file_discrepancies:
            prop = d.get("property_name", "-")
            constraint = d.get("constraint_type", "-")
            dtype = d.get("discrepancy_type", "-")
            spec_val = d.get("spec_value", "-")
            api_val = d.get("api_behavior", "-")

            # Format values for table
            spec_str = _format_value(spec_val)
            api_str = _format_value(api_val)
            dtype_badge = _get_type_badge(dtype)

            lines.append(f"| `{prop}` | `{constraint}` | {dtype_badge} | {spec_str} | {api_str} |")

        lines.append("")

    # Modification types legend
    lines.extend(
        [
            "## Modification Types",
            "",
            "| Type | Description |",
            "|------|-------------|",
            "| :material-arrow-up-bold-circle: **Relaxed** | Constraint was too strict - API accepts values the spec rejected |",
            "| :material-arrow-down-bold-circle: **Tightened** | Constraint was too loose - API rejects values the spec accepted |",
            "| :material-plus-circle: **Added** | Missing constraint discovered through API testing |",
            "| :material-minus-circle: **Removed** | Extra constraint that API ignores |",
            "",
        ]
    )

    # Footer
    lines.extend(
        [
            "---",
            "",
            "*This page is auto-generated by the [validation pipeline](https://github.com/robinmordasiewicz/f5xc-api-fixed/actions).*",
        ]
    )

    _write_file(output_path, lines)


def _format_value(value) -> str:
    """Format a value for display in markdown table."""
    if value is None:
        return "-"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, (list, dict)):
        return (
            f"`{json.dumps(value)[:50]}...`" if len(str(value)) > 50 else f"`{json.dumps(value)}`"
        )
    # Replace newlines with HTML line breaks for markdown tables
    str_value = str(value).replace("\n", "<br>")
    # Don't wrap in backticks if it contains HTML (backticks escape HTML entities)
    if "<br>" in str_value:
        return str_value
    return f"`{str_value}`"


def _get_type_badge(dtype: str) -> str:
    """Get a badge for the discrepancy type."""
    badges = {
        "spec_stricter": ":material-arrow-up-bold-circle:{ .relaxed } Relaxed",
        "spec_looser": ":material-arrow-down-bold-circle:{ .tightened } Tightened",
        "missing_constraint": ":material-plus-circle:{ .added } Added",
        "extra_constraint": ":material-minus-circle:{ .removed } Removed",
        "constraint_mismatch": ":material-swap-horizontal:{ .mismatch } Mismatch",
        "type_mismatch": ":material-format-letter-case:{ .type } Type",
    }
    return badges.get(dtype, dtype)


def _write_file(path: Path, lines: list[str]) -> None:
    """Write lines to file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        f.write("\n".join(lines))
    console.print(f"[green]Generated: {path}[/green]")


def main() -> int:
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(description="Generate documentation from validation reports")
    parser.add_argument(
        "--report",
        type=Path,
        default=Path("reports/validation_report.json"),
        help="Path to validation report JSON",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("docs/index.md"),
        help="Output path for modifications page",
    )

    args = parser.parse_args()

    console.print("[bold blue]Generating Documentation[/bold blue]")

    # Load report
    report = load_validation_report(args.report)

    # Generate modifications page
    generate_modifications_page(report, args.output)

    console.print("[green]Documentation generation complete[/green]")
    return 0


if __name__ == "__main__":
    sys.exit(main())
